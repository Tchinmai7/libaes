<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf8">
<title>Flawfinder Results</title>
<meta name="author" content="David A. Wheeler">
<meta name="keywords" lang="en" content="flawfinder results, security scan">
</head>
<body>
<h1>Flawfinder Results</h1>
Here are the security scan results from
<a href="https://dwheeler.com/flawfinder">Flawfinder version 2.0.7</a>,
(C) 2001-2017 <a href="https://dwheeler.com">David A. Wheeler</a>.
Number of rules (primarily dangerous function names) in C/C++ ruleset: 223
<p>
Examining ./aes.h <br>
Examining ./utils.c <br>
Examining ./driver.c <br>
Examining ./encrypt.h <br>
Examining ./decrypt.c <br>
Examining ./utils.h <br>
Examining ./inv_aes.c <br>
Examining ./inv_aes.h <br>
Examining ./encrypt.c <br>
Examining ./aes.c <br>
Examining ./decrypt.h <br>

<h2>Final Results</h2>
<ul>
<li>./aes.c:56: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
	memcpy(param-&gt;key, key, key_size);
</pre>
<li>./aes.c:87: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
    memcpy(input, temp, 4);
</pre>
<li>./aes.c:102: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
    memcpy(input, temp, 4);
</pre>
<li>./aes.c:146: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
        memcpy(w + i , temp, 4);
</pre>
<li>./aes.c:152: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
            memcpy(temp, w + j - 4 ,4);
</pre>
<li>./aes.c:251: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
    memcpy(temp, w, 16);
</pre>
<li>./aes.c:280: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
        memcpy(temp, w + (round * 4 * 4), 16);
</pre>
<li>./aes.c:291: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
    memcpy(temp, w + (Nr * 4 * 4), 16);
</pre>
<li>./decrypt.c:10: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
	memcpy(iv, input, 16);
</pre>
<li>./decrypt.c:27: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(iv, temp_op, 16);
</pre>
<li>./decrypt.c:29: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(block, input + (i*16), 16);
</pre>
<li>./decrypt.c:31: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(output+((i-1)*16), temp_op, 16);
</pre>
<li>./decrypt.c:42: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
	memcpy(iv, input, 16);
</pre>
<li>./decrypt.c:58: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(block, input + (i*16), 16);
</pre>
<li>./decrypt.c:60: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(output+((i-1)*16), temp_op, 16);
</pre>
<li>./decrypt.c:61: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(iv, block, 16);
</pre>
<li>./decrypt.c:76: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(block, input + (i*16), 16);
</pre>
<li>./decrypt.c:78: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(output+(i*16), temp_op, 16);
</pre>
<li>./decrypt.c:89: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
	memcpy(iv, input, 16);
</pre>
<li>./decrypt.c:104: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(block, input + (i*16), 16);
</pre>
<li>./decrypt.c:107: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(output+((i-1)*16), temp_op, 16);
</pre>
<li>./decrypt.c:108: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(iv,block,16);
</pre>
<li>./driver.c:62: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
    memcpy(input, argv[1], input_size);
</pre>
<li>./encrypt.c:21: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
	memcpy(output, iv, 16);
</pre>
<li>./encrypt.c:28: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
        memcpy(iv, temp_op,16);
</pre>
<li>./encrypt.c:29: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(block, input+(i*16), 16);
</pre>
<li>./encrypt.c:32: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(output+(i*16)+16, temp_op, 16);
</pre>
<li>./encrypt.c:52: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
	memcpy(output, iv, 16);
</pre>
<li>./encrypt.c:60: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(block, input+(i*16), 16);
</pre>
<li>./encrypt.c:62: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(output+(i*16)+16, temp_op, 16);
</pre>
<li>./encrypt.c:63: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(iv, temp_op,16);
</pre>
<li>./encrypt.c:77: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(block, input+(i*16), 16);
</pre>
<li>./encrypt.c:79: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(output+(i*16), temp_op, 16);
</pre>
<li>./encrypt.c:100: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
	memcpy(output, iv, 16);
</pre>
<li>./encrypt.c:104: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(block, input+(i*16), 16);
</pre>
<li>./encrypt.c:107: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(output+(i*16)+16, temp_op, 16);
</pre>
<li>./encrypt.c:108: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
		memcpy(iv, temp_op,16);
</pre>
<li>./inv_aes.c:139: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
    memcpy(temp, w + (Nr * 4 * 4), 16);
</pre>
<li>./inv_aes.c:158: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
        memcpy(temp, w + (round * 4 * 4), 16);
</pre>
<li>./inv_aes.c:169: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
    memcpy(temp, w, 16);
</pre>
<li>./utils.c:109: <b>  [2] </b> (misc) <i> fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move things
  around to create a race condition, control its ancestors, or change its
  contents? (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>). </i>
<pre>
	f = fopen("/dev/urandom", "r");
</pre>
<li>./driver.c:47: <b>  [1] </b> (buffer) <i> strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (<a
  href="https://cwe.mitre.org/data/definitions/126.html">CWE-126</a>). </i>
<pre>
    size_t input_size = strlen(argv[1]);
</pre>
</ul>
<h2>Analysis Summary</h2>
<p>
Hits = 42
<br>
Lines analyzed = 1011 in approximately 0.05 seconds (22094 lines/second)
<br>
Physical Source Lines of Code (SLOC) = 848
<br>
Hits@level = [0]  60 [1]   1 [2]  41 [3]   0 [4]   0 [5]   0 <br>
Hits@level+ = [0+] 102 [1+]  42 [2+]  41 [3+]   0 [4+]   0 [5+]   0 <br>
Hits/KSLOC@level+ = [0+] 120.283 [1+] 49.5283 [2+] 48.3491 [3+]   0 [4+]   0 [5+]   0 <br>
Dot directories skipped = 1 (--followdotdir overrides)
<br>
Minimum risk level = 1
<br>
Not every hit is necessarily a security vulnerability.
<br>
There may be other security vulnerabilities; review your code!
<br>
See '<a href="https://dwheeler.com/secure-programs">Secure Programming HOWTO</a>'
(<a href="https://dwheeler.com/secure-programs">https://dwheeler.com/secure-programs</a>) for more information.
</body>
</html>
